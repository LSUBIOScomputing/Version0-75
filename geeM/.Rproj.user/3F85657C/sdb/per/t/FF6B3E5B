{
    "contents" : "getfam <- function(family){\n  if(is.character(family)){\n    family <- get(family, mode = \"function\", envir = parent.frame(2))  \n  }\n  \n  if(is.function(family)){\n    family <- family()\n    return(family)\n  }else if(inherits(family, \"family\")){\n    return(family)\n  }else if(is.list(family)){\n    if(length(match(names(family), c(\"LinkFun\", \"VarFun\", \"InvLink\", \"InvLinkDeriv\"))) == 4){\n      famname <- \"custom\"\n      LinkFun <- family$LinkFun\n      InvLink <- family$InvLink\n      VarFun <- family$VarFun\n      InvLinkDeriv <- family$InvLinkDeriv\n    }else{\n      famname <- \"custom\"\n      LinkFun <- family[[1]]\n      VarFun <- family[[2]]\n      InvLink <- family[[3]]\n      InvLinkDeriv <- family[[4]]\n    }\n    \n    \n    FunList <- list(\"family\"= famname, \"LinkFun\" = LinkFun, \"VarFun\" = VarFun, \"InvLink\" = InvLink, \"InvLinkDeriv\" = InvLinkDeriv) \n    return(FunList)\n  }else{\n    stop(\"problem with family argument: should be string, family object, or list of functions\")\n  }\n}\n\n### Get a block diagonal matrix. Each block has dimension corresponding to\n### each cluster size.  By default, each block is just a matrix filled with ones.\ngetBlockDiag <- function(len, xvec=NULL){\n  K <- length(len)\n  if(is.null(xvec)){\n    xvec <- rep.int(1, sum(len^2))\n  }\n  \n  row.vec <- col.vec <- vector(\"numeric\", sum(len^2))\n  add.vec <- cumsum(len) - len\n  index <- c(0, (cumsum(len^2) -len^2)[2:K], sum(len^2)) \n  for(i in 1:K){\n    row.vec[(index[i] + 1):(index[i+1])] <- rep.int( (1:len[i]) + add.vec[i], len[i])\n    col.vec[(index[i] + 1):(index[i+1])] <- rep( (1:len[i]) + add.vec[i], each=len[i])\n  }\t\n  BlockDiag <- sparseMatrix(i = row.vec, j = col.vec, x = xvec)\n  return(list(BDiag = as(BlockDiag, \"symmetricMatrix\"), row.vec =row.vec, col.vec=col.vec))\n}\n\n\n### Check some conditions on the FIXED correlation structure.\ncheckFixedMat <- function(corr.mat, len){\n  if(is.null(corr.mat)){\n    stop(\"corr.mat must be specified if using fixed correlation structure\")\n  }\n  if(dim(corr.mat)[1] < max(len)){\n    stop(\"Dimensions of corr.mat must be at least as large as largest cluster\")\n  }\n  if(!isSymmetric(corr.mat)){\n    stop(\"corr.mat must be symmetric\")\n  }\n  if(determinant(corr.mat, logarithm=T)$modulus == -Inf){\n    stop(\"supplied correlation matrix is not invertible.\")\n  }\t\n  return(corr.mat[1:max(len), 1:max(len)])\t\n}\n\n\n\n\n\n### fitted function for geem object\nfitted.geem <- function(object, ...){\n  InvLink <- object$FunList$InvLink\n  return(InvLink(object$eta))\n}\n\npredict.geem <- function(object, newdata = NULL,...){\n  coefs <- object$beta\n  if(is.null(newdata)){\n    return(as.vector(object$X %*% object$beta))\n  }else{\n    if(dim(newdata)[2] != length(coefs)){warning(\"New observations must have the same number of rows as coefficients in the model\")}\n    return(as.vector(newdata %*% object$beta))\n  }\n}\n\ncoef.geem <- function(object, ...){\n  coefs <- object$beta\n  names(coefs) <- object$coefnames\n  return(coefs)\n}\n\nfamily.geem <- function(object,...){\n  \n  return(object$FunList)\n}\n\n\n\n",
    "created" : 1432239231010.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2412593266",
    "id" : "FF6B3E5B",
    "lastKnownWriteTime" : 1432568569,
    "path" : "C:/Users/lmcda4/Dropbox/geeM/Version0-75/geeM/R/utility.R",
    "project_path" : "R/utility.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}